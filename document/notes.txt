2022-05-05

I am using github.com/Thomas-Walker-Lynch/resources.  This includes the directory names 'executable library source document' instead
of 'bin lib src docs'  for the LFS build scripts repo - not for LFS!

Divergences from the book:

  1. The initial user created with the Debian install (on the QEMU virtual machine)
  is already lfs.  We don't start out as root in the book.  Hence we do not need to add the lfs user and
  fix permissions in s4.3.  I am wondering if we will need a grand fix permissions at some point.

Scripts are in flux .. see notes in the scripts

still neeed to apply patches s3.3

s7.07_libstdc++
  #the book has this, but gthr-posix.h is inside libgcc
  #ln -s gthr-posix.h libgcc/gthr-default.h
  ln -s libgcc/gthr-posix.h libgcc/gthr-default.h
  ...
    #this has to be done with sudo because the build process runs as root and it modifies the source tree
    sudo rm -rf source/$SOURCE_DIR

book does not conform to RFC2119


2022-05-07T17:07:32Z

  An AI approach to this would have a verb that given a tar package would return its dependencies.  Then we
  would create a dependency graph and traverse it to find the parallizable build order.  That would then
  generate the build script.

  Given that various tar packages have different build script, we need to keep a list that pairs tar
  packages with build scripts.

  The problem here is that such a depency verb is not computable.  Clever code could dynamically call
  for things we do not see in a static analysis.

  In addition we would like that all executable code is read only, and then keep data separately.  Would
  be nice to have a tag based file system so that we can apply multiple topologies.  One topology for
  the standard linux view, and another topology for the more AI like discussion of the role of the various
  files.

